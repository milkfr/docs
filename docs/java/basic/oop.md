---
title: 面向对象
---

## 类的初始化和清理
### 为什么要有初始化和清理
有两个安全性的问题：初始化和清理

C语言中很多bug是因为程序员忘记初始化导致，尤其是很多类库的使用者不知道如何初始化类库组建，但是必须得去初始化

清理是另一个特殊的问题，当使用一个元素完事后就不会去关心这个元素，容易忘记清理它，造成了元素使用的资源滞留不会被回收，直到程序消耗完所有资源（特别是内存）

Java采用类构造器的概念，每创建一个对象，这个方法就会被自动调用，另外还是用了垃圾回收器（Garbage Collector，GC），去回收不在被使用的对象所占的资源

### 构造器的初始化挑战
#### 命名构造器方法的挑战

* 任何命名都可能与类中其他已有元素的命名冲突
* 编译器必须始终知道构造器的方法名称

采用了和C++的解决方法，构造器名称与类名相同

#### 构造器方法重载的挑战

* 如何区分两个相同命名的方法

目前只能通过一条简单的规则：每个被重载的方法必须有独一无二的参数列表

* 为什么不通过返回值区分方法

因为很多情况下，编译器很容易就可以从上下文准确推断出该调用哪个方法，但是存在程序员不在乎返回值，不需要返回值的情况，这样编译器就不能确定想要调用的方法，阅读者也不知道，所以不能根据返回值区分，同理构造函数只能使用void

#### this关键字的问题

为了区分两个相同类型的对象，比如a和b，调用两个对象的方法的时候，为了区分a和b，编译器实际上做了这样的工作

```java
class.func(a, 1)
class.func(b, 1)
```

当我们需要在类的内部使用时，用的this关键字，因为this关键字的特殊性，影响了一些构造器的问题

* 如何在构造器中调用构造器

有时候为了方法复用，需要在构造器中使用到另一个构造器

```java
Class Flower {
    Flower(String s, int petals) {
        this(petals);
        //- this(s);  // Can't call two!
        this.s = s;  // Another use of "this"
        System.out.println("String & int args");
    }
}
```

如上可以在构造器中通过this调用另一个构造器，而且只能调用一次，成员函数中不可以调用构造器

### 垃圾回收器
to be continued ...
